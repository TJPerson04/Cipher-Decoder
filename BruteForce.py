from collections.abc import Callable
import time
from WordDictionary import WordDictionary
import os
import threading

class BruteForce:
    def __init__(self, encoded_text: str, cipher_func: Callable[[str, str], str], num_digits, word_dict: WordDictionary = WordDictionary(),num_cores: int = 16, separators: tuple[bool, bool, bool] = (4, 6, 12), starting_key_part: list[str]=[""]):
        '''
        Will try and solve the given cipher using keys generated by trying every possible combination of characters.\n

        encoded_text: The encoded string of text\n
        cipher_func: The cipher function to call that encodes a given string\n
        num_digits: The number of digits to test. The higher this value, the longer the test will take.\n

        word_dict: The associated WordDictionary\n
        num_cores: The number of separate threads to run at once\n
        separators: Breakpoints for how long the valid word in the decoded text must be to be logged (each section will be in a different file)\n
        starting_key_part: If given, this will add the given string to the beginning of each key
        '''
        self.encoded_text = encoded_text
        self.cipher_func = cipher_func
        self.num_digits = num_digits
        self.word_dict = word_dict
        self.num_cores = num_cores
        self.separators = separators
        self.starting_key_part = starting_key_part
    
    
    def contains_valid_word_by_size(self, text: str) -> tuple[bool, bool, bool]:
        '''
        Returns three bools of decreasing security, using the separators property to separate the output by 
        the length of the valid word in the given string.
        '''
        out1 = False
        out2 = False
        text_ar = text.replace('.', '').split(' ')
        for word in text_ar:
            if (len(word) < self.separators[0]):
                continue

            if (self.word_dict.is_word(word)):
                out1 = True

                if (len(word) > self.separators[1]):
                    out2 = True
            
                if (len(word) > self.separators[2]):
                    return (True, True, True)
    
        return (out1, out2, False)
    
    def check_solution(self, word: str, decoded_text: str, file_1, file_2, file_3, is_valid: tuple[bool, bool, bool]):
        if (not is_valid[0]):
            return
    
        output_text = f'key: {word} | text: {decoded_text}\n'
    
        file_1.write(output_text)

        if (is_valid[1]):
            print("-------")
            print(output_text)
            file_2.write(output_text)
    
        if (is_valid[2]):
            file_3.write(output_text)

    def get_estimated_run_time(self):
        startTime = time.time_ns()

        # Run a couple checks and see how long that takes
        for i in range(26):
            word = self.starting_key_part[0] + self.word_dict.ALPHABET[i]
            decoded_text = self.cipher_func(self.encoded_text, word)
            self.word_dict.contains_valid_word(decoded_text)

        endTime = time.time_ns()

        timeMult = ((len(self.starting_key_part) * len(self.word_dict.ALPHABET)) ** self.num_digits) / self.num_cores / 2

        return (endTime - startTime) * timeMult
    
    def print_estimated_run_time(self):
        estimated_time_ns = self.get_estimated_run_time()
        
        seconds = estimated_time_ns // 1_000_000_000
        minutes = seconds // 60
        hours = minutes // 60

        seconds %= 60
        minutes %= 60
        hours %= 60

        print(f'TEST: {estimated_time_ns}')
        print(f'Estimated Completion Time: {hours}h {minutes}m {seconds}s')

    
    def loop_through_all_chars_recursive(self, text: str, num_digits: int, output_1, output_2, output_3):
        for letter in self.word_dict.ALPHABET:
            new_text = text + letter

            if num_digits == 4:
                output_1.flush()
                output_2.flush()
                output_3.flush()

            if num_digits > 1:
                self.loop_through_all_chars_recursive(new_text, num_digits - 1, output_1, output_2, output_3)
            
            # Test the combination as a key
            decoded_text = self.cipher_func(self.encoded_text, new_text)
            is_valid = self.contains_valid_word_by_size(decoded_text)
            self.check_solution(new_text, decoded_text, output_1, output_2, output_3, is_valid)

    def thread_func(self, start: int, end: int, thread_index: int, print_progress=True):
        '''
        Tests all possible combinations of letters for key
        '''

        # Log the start
        if (print_progress):
            print("Starting thread " + str(thread_index))
        
        # Specific number of letter keys
        with open(f'output_{self.separators[0] + 1}_letters_{thread_index}.txt', 'w') as output_1, open(f'output_{self.separators[1] + 1}_letters_{thread_index}.txt', 'w') as output_2, open(f'output_{self.separators[2] + 1}_letters_{thread_index}.txt', 'w') as output_3:
            for keyStart in self.starting_key_part:
                if (self.starting_key_part != ""):
                    word = keyStart
                    decoded_text = self.cipher_func(self.encoded_text, word)
                    is_valid = self.contains_valid_word_by_size(decoded_text)
                    self.check_solution(word, decoded_text, output_1, output_2, output_3, is_valid)

                for i in range(end - start + 1):
                    index = start + i
                    letter1 = self.word_dict.ALPHABET[index]
                    word = keyStart + letter1
                    decoded_text = self.cipher_func(self.encoded_text, word)
                    is_valid = self.contains_valid_word_by_size(decoded_text)
                    self.check_solution(word, decoded_text, output_1, output_2, output_3, is_valid)

                    self.loop_through_all_chars_recursive(keyStart + self.word_dict.ALPHABET[index], self.num_digits - 1, output_1, output_2, output_3)
    
        if (print_progress):
            print(f'Ending thread {thread_index}')
    
    def get_bounds(self) -> list[tuple[int, int]]:
        '''
        Returns a list of size num_cores. This list contains tuples of (start_index, end_index)\n
        CURRENTLY UNDER CONSTRUCTION
        '''
        pass

    def concat_output_files(self):
        for i in range(3):
            filenames = []
            for j in range(self.num_cores):
                filenames.append(f'output_{self.separators[i] + 1}_letters_{j}.txt')
            with open(f'output_{self.separators[i] + 1}_letters.txt', 'a') as outfile:
                for fname in filenames:
                    with open(fname) as infile:
                        for line in infile:
                            outfile.write(line)

                    os.remove(fname)                    


    ### SOLVING FUNCTIONS ###
    
    def solve(self, print_progress=True):
        # Create all the threads
        threads = []
        section_size = 2
        for i in range(self.num_cores):
            start_index = section_size * i
            end_index = start_index + section_size - 1
            if i > 9:
                start_index = section_size * 9
                start_index = start_index + i - 8
                end_index = start_index
            if i == 15:
                start_index = 25
                end_index = 25
            
            if (print_progress):
                print(f'({start_index}, {end_index})')
            new_thread = threading.Thread(target=self.thread_func, args=(start_index, end_index, i, print_progress))
            threads.append(new_thread)

        self.print_estimated_run_time()
        
        #Start the threads
        for thread in threads:
            thread.start()

        # Wait for the threads to join
        if (print_progress):
            print("Now waiting for threads to finish")
        for thread in threads:
            thread.join()
        
        self.concat_output_files()